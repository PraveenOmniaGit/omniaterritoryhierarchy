<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>D3 Vertical Tree with Expand/Collapse & Node Box</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #fafafa;
        }

        ::-webkit-scrollbar {
            width: 7px;
            /* Width of the vertical scrollbar */
        }

        ::-webkit-scrollbar:horizontal {
            height: 7px;
            /* Height of the horizontal scrollbar */
        }

        ::-webkit-scrollbar-track {
            margin: 0 !important;
            border: none;
            background: #fff;
            /* Remove any space around the track */
        }

        ::-webkit-scrollbar-thumb {
            background-color: #c1c1c1 !important;
            /* Thumb color */
            border-radius: 10px;
            /* Rounded corners for the thumb */
        }

        ::-webkit-scrollbar-thumb:horizontal {
            background-color: #cdcdcd !important;
            /* Thumb color */
            border-radius: 10px;
            /* Rounded corners for the thumb */
        }

        .node-label,
        .node-role,
        .node-jobtitle,
        .node-email {
            font-family: 'Segoe UI', Arial, sans-serif !important;
            letter-spacing: 0.01em;
        }

        #tree-container {
            width: 100%;
            height: 100vh;
            overflow: auto;
            background: #fafafa;
            position: relative;
            /* margin-top: 90px; */
        }

        .control-buttons {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-button {
            padding: 11px 18px;
            background: linear-gradient(90deg, #1976D2 0%, #2196F3 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            font-family: 'Segoe UI', 'Arial', 'Helvetica Neue', Helvetica, sans-serif !important;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.10);
            transition: background 0.2s, color 0.2s, box-shadow 0.2s, border 0.2s;
            outline: none;
            cursor: pointer;
        }

        .control-button:hover,
        button:hover,
        select:hover,
        input[type="button"]:hover,
        input[type="submit"]:hover {
            background: linear-gradient(90deg, #1565C0 0%, #1976D2 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(25, 118, 210, 0.18);
        }

        .toggle-icon {
            font-size: 20px;
            font-weight: bold;
            text-anchor: middle;
            fill: #000;
            cursor: pointer;
            user-select: none;
            paint-order: stroke;
            stroke: white;
            stroke-width: 4px;
        }

        #tree-container {
            cursor: grab;
        }

        #tree-container.dragging {
            cursor: grabbing;
        }

        /* Custom multi-select dropdown with checkboxes */
        .custom-multiselect {
            position: relative;
            display: inline-block;
            min-width: 170px;
            margin-right: 16px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }

        .custom-multiselect-btn {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(90deg, #f8fafc 0%, #e3f2fd 100%);
            color: #1565C0;
            border: 1.5px solid #1976D2;
            border-radius: 6px;
            font-size: 17px;
            font-weight: 500;
            fill: #4b6584;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            letter-spacing: 0.1px;
            text-align: left;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
            transition: border 0.2s, box-shadow 0.2s;
            outline: none;
            display: flex;
            align-items: center;
        }

        .custom-multiselect-btn:after {
            content: '\25BC';
            float: right;
            font-size: 12px;
            color: #1976D2;
            margin-left: auto;
        }

        .custom-multiselect-btn.active,
        .custom-multiselect-btn:focus {
            border-color: #0d47a1;
            box-shadow: 0 4px 16px rgba(25, 118, 210, 0.15);
        }

        .custom-multiselect-dropdown {
            display: none;
            position: absolute;
            top: 110%;
            left: 0;
            margin-top: 4px;
            background: #fff;
            border: 1.5px solid #1976D2;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(25, 118, 210, 0.15);
            z-index: 10001;
            width: 170px;
            min-width: 170px;
            max-width: 170px;
            padding: 8px 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            border-radius: 10px;
            box-shadow: 0 6px 24px rgba(25, 118, 210, 0.18);
        }

        .custom-multiselect-dropdown.show {
            display: block;
        }

        .custom-multiselect-option {
            display: flex;
            align-items: center;
            padding: 10px 18px;
            font-size: 16px;
            color: #1976D2;
            cursor: pointer;
            background: none;
            border: none;
            width: 100%;
            font-family: inherit;
            border-bottom: none;
            transition: background 0.15s, color 0.15s;
        }

        .custom-multiselect-option:last-child {
            /* No border needed, already removed above */
        }

        .custom-multiselect-option:hover {
            background: #e3f2fd !important;
            color: #0d47a1 !important;
        }

        .custom-multiselect-option input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #1976D2;
        }


        .type-select {
            padding: 8px 12px;
            border: 1.5px solid #1976D2;
            border-radius: 6px;
            font-size: 17px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: linear-gradient(90deg, #f8fafc 0%, #e3f2fd 100%);
            color: #1565C0;
            cursor: pointer;
            outline: none;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
            font-weight: 500;
            letter-spacing: 0.2px;
            transition: border 0.2s, box-shadow 0.2s;
        }

        .type-select:focus,
        .type-select:hover {
            border-color: #0d47a1;
            box-shadow: 0 4px 16px rgba(25, 118, 210, 0.15);
        }

        .type-select option {
            font-size: 15px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            color: #1976D2;
            padding: 6px 10px;
            background: #fff;
        }


        .date-picker {
            padding: 8px 12px;
            border: 1.5px solid #1976D2;
            border-radius: 6px;
            font-size: 17px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: linear-gradient(90deg, #f8fafc 0%, #e3f2fd 100%);
            color: #1565C0;
            margin-left: 10px;
            display: none;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
            font-weight: 500;
            letter-spacing: 0.2px;
            transition: border 0.2s, box-shadow 0.2s;
        }

        .date-picker:hover {
            border-color: #999;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .app-layout {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #tree-container {
            overflow: auto;
        }
    </style>
</head>

<body>
    <div class="control-buttons">
        <select class="type-select" onchange="handleTypeChange(this.value)">
            <option value="current">Current</option>
            <option value="finance">Financial</option>
            <option value="custom">Custom</option>
        </select>
        <input type="date" class="date-picker" onchange="handleDateChange(this.value)">
        <div class="custom-multiselect" id="customMultiSelect">
            <button type="button" class="custom-multiselect-btn" id="customMultiSelectBtn">Select fields</button>
            <div class="custom-multiselect-dropdown" id="customMultiSelectDropdown">
                <label class="custom-multiselect-option"><input type="checkbox" value="photo" checked> Photo</label>
                <label class="custom-multiselect-option"><input type="checkbox" value="name" checked disabled>
                    Name</label>
                <label class="custom-multiselect-option"><input type="checkbox" value="jobtitle"> Job Title</label>
                <label class="custom-multiselect-option"><input type="checkbox" value="email"> Email</label>
                <label class="custom-multiselect-option"><input type="checkbox" value="role" checked> Role</label>
            </div>
        </div>
        <button class="control-button" onclick="expandAll()">Expand All</button>
        <button class="control-button" onclick="collapseAll()">Collapse All</button>
        <button class="control-button" onclick="downloadPDF()">Download as PDF</button>
    </div>
    <div class="app-layout">
        <div id="tree-container">
            <svg></svg>
        </div>
        <div id="node-popup"
            style="position: fixed; top: 0px; right: -550px; width: 30%; height: 100%; background: rgb(255, 255, 255); box-shadow: rgba(25, 118, 210, 0.1) -2px 0px 16px; transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 2000; overflow: hidden auto; font-family: &quot;Segoe UI&quot;, Arial, &quot;Helvetica Neue&quot;, Roboto, sans-serif; display: none;">
            <button id="close-popup-btn"
                style="z-index: 2000;position:absolute;top:18px;right:18px;background:none;border:none;font-size:28px;color:#fff;cursor:pointer;">×</button>
            <div id="popup-content"></div>
        </div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvg@3.0.10/lib/umd.min.js"></script>

    <script>
        const roleColors = {
            "division supervisor": { fill: "#e3f0ff", stroke: "#1e40af", linkColor: "#1e40af" }, // blue
            "division leader": { fill: "#fce4ec", stroke: "#ad1457", linkColor: "#ad1457" }, // pink
            "current": { fill: "#e8f5e9", stroke: "#388e3c", linkColor: "#388e3c" }, // green
            "group leader": { fill: "#fff8e1", stroke: "#f9a825", linkColor: "#f9a825" }, // yellow
            "group supervisor": { fill: "#e0f7fa", stroke: "#00838f", linkColor: "#00838f" }, // teal
            "territory supervisor": { fill: "#f3e5f5", stroke: "#6a1b9a", linkColor: "#6a1b9a" }, // purple
            "territory manager": { fill: "#fbe9e7", stroke: "#d84315", linkColor: "#d84315" } // orange
        };

        // --- Custom Multi-Select Dropdown Logic ---
        (function () {
            const btn = document.getElementById('customMultiSelectBtn');
            const dropdown = document.getElementById('customMultiSelectDropdown');
            const container = document.getElementById('customMultiSelect');
            const checkboxes = dropdown.querySelectorAll('input[type="checkbox"]');

            function updateBtnLabel() {
                const selected = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.parentNode.textContent.trim());
                btn.textContent = selected.length ? selected.join(', ') : 'Select fields';
            }

            // Initial label update on page load
            updateBtnLabel();

            btn.addEventListener('click', function (e) {
                dropdown.classList.toggle('show');
                btn.classList.toggle('active');
            });


            // Debounce function to limit how often updateNodeFieldsVisibility runs
            let updateFieldsTimeout = null;
            function debounceUpdateNodeFieldsVisibility() {
                if (updateFieldsTimeout) clearTimeout(updateFieldsTimeout);
                updateFieldsTimeout = setTimeout(() => {
                    updateNodeFieldsVisibility();
                }, 150); // 150ms delay for batching
            }

            checkboxes.forEach(cb => {
                cb.addEventListener('change', function () {
                    updateBtnLabel();
                    dropdown.classList.remove('show');
                    btn.classList.remove('active');
                    debounceUpdateNodeFieldsVisibility();
                });
            });

            document.addEventListener('mousedown', function (e) {
                if (!container.contains(e.target)) {
                    dropdown.classList.remove('show');
                    btn.classList.remove('active');
                    updateBtnLabel();
                }
            });
        })();

        let treeRoot; // Store the root node globally

        function downloadPDF() {
            const container = document.getElementById('tree-container');

            const MAX_SIZE = 14400;

            const originalStyle = {
                width: container.style.width,
                height: container.style.height,
                overflow: container.style.overflow,
                scrollTop: container.scrollTop,
                scrollLeft: container.scrollLeft
            };

            container.style.overflow = 'visible';
            container.style.width = container.scrollWidth + 'px';
            container.style.height = container.scrollHeight + 'px';

            const width = container.scrollWidth;
            const height = container.scrollHeight;

            // Step 2: Define jsPDF max page size (in px)
            const MAX_PDF_SIZE = 20000; // allow larger page size

            // Step 3: Use a higher scale for even more clarity
            let scaleFactor = 4;
            if (width * scaleFactor > MAX_PDF_SIZE || height * scaleFactor > MAX_PDF_SIZE) {
                scaleFactor = Math.min(MAX_PDF_SIZE / width, MAX_PDF_SIZE / height);
            }

            const scaledWidth = width * scaleFactor;
            const scaledHeight = height * scaleFactor;

            html2canvas(container, {
                backgroundColor: "#fff",
                useCORS: true,
                allowTaint: false,
                imageTimeout: 15000,
                scale: scaleFactor,
                scrollX: 0,
                scrollY: 0,
                windowWidth: width,
                windowHeight: height
            }).then(canvas => {
                const imgData = canvas.toDataURL('image/png');

                // Use a larger PDF page size (A2 landscape)
                const pdf = new window.jspdf.jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a2'
                });

                // Calculate dimensions to fit nicely in A2
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                let renderWidth = pageWidth;
                let renderHeight = (scaledHeight / scaledWidth) * pageWidth;
                if (renderHeight > pageHeight) {
                    renderHeight = pageHeight;
                    renderWidth = (scaledWidth / scaledHeight) * pageHeight;
                }

                pdf.addImage(imgData, 'PNG', 0, 0, renderWidth, renderHeight);
                pdf.save('organization-chart.pdf');
            }).catch(() => {
                alert('Failed to generate PDF. Please try again.');
            }).finally(() => {
                // Restore original styles and scroll
                container.style.width = originalStyle.width;
                container.style.height = originalStyle.height;
                container.style.overflow = originalStyle.overflow;
                container.scrollTop = originalStyle.scrollTop;
                container.scrollLeft = originalStyle.scrollLeft;
            });

        }


        function handleTypeChange(value) {
            currentType = value;
            const datePicker = document.querySelector('.date-picker');
            hideDrawer();
            if (value === 'custom') {
                datePicker.style.display = 'inline-block';
            } else {
                datePicker.style.display = 'none';
                datePicker.value = '';
                loadData(value);
            }
        }

        function handleDateChange(date) {
            hideDrawer();
            loadData('custom', date);
        }

        let currentType = "current";

        function getStorageKey(type) {
            return "treeState_" + type;
        }

        function saveNodeState(type, root) {
            const state = {};
            function recurse(node) {
                state[node.data.nodeId] = !!node.children;
                if (node.children) node.children.forEach(recurse);
                if (node._children) node._children.forEach(recurse);
            }
            recurse(root);
            localStorage.setItem(getStorageKey(type), JSON.stringify(state));
        }

        function loadNodeState(type) {
            const raw = localStorage.getItem(getStorageKey(type));
            return raw ? JSON.parse(raw) : {};
        }


        function restoreNodeState(root, state) {
            function recurse(node) {
                const isExpanded = state[node.data.nodeId];
                if (isExpanded === false && node.children) {
                    node._children = node.children;
                    node.children = null;
                }
                if (node.children) node.children.forEach(recurse);
                if (node._children) node._children.forEach(recurse);
            }
            recurse(root);
        }

        function loadData(type, customDate = null) {
            // Show loading state
            const svg = d3.select("svg");
            svg.selectAll("*").remove();

            let url = apiUrl;
            let chartType = 0;
            if (type === 'finance') {
                chartType = 1;
            } else if (type === 'custom' && customDate) {
                chartType = 2;
            }

            let details = {
                chartType: chartType,
                AsOfNow: customDate ? new Date(customDate).toISOString() : null
            }

            fetch(url, {
                method: 'POST', // HTTP method
                headers: {
                    'Content-Type': 'application/json', // MIME type
                },
                body: JSON.stringify(details)
            })
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(rawData => {
                    if (!rawData || rawData.length === 0) {
                        throw new Error('No data received');
                    }
                    treeRoot = buildHierarchy(rawData);

                    const savedState = loadNodeState(type);
                    restoreNodeState(treeRoot, savedState);

                    layoutTree(treeRoot);
                    renderTree(treeRoot);
                    updateNodeFieldsVisibility();
                })
                .catch(err => {
                    console.error("Error loading data:", err);
                    // Show error message in the SVG
                    svg.selectAll("*").remove();
                    svg.append("text")
                        .attr("x", "50%")
                        .attr("y", "50%")
                        .attr("text-anchor", "middle")
                        .style("font-size", "16px")
                        .style("fill", "red")
                        .text("Error loading data. Please try again.");
                });
        }

        function expandAll() {
            hideDrawer();
            expandCollapseAll(treeRoot, true);
            saveNodeState(currentType, treeRoot);
            layoutTree(treeRoot);
            renderTree(treeRoot);
            // No need to call updateNodeFieldsVisibility here, renderTree redraws everything
        }

        function collapseAll() {
            window._centerRootNextRender = true;
            hideDrawer();
            expandCollapseAll(treeRoot, false);
            saveNodeState(currentType, treeRoot);
            layoutTree(treeRoot);
            renderTree(treeRoot, true); // pass centerRoot flag
            // No need to call updateNodeFieldsVisibility here, renderTree redraws everything
        }

        function hideDrawer() {
            const popup = document.getElementById('node-popup');
            if (popup) {
                popup.style.right = '-400px';
                setTimeout(() => { popup.style.display = 'none'; }, 400); // match transition
            }
            const treeContainer = document.getElementById('tree-container');
            if (treeContainer) {
                treeContainer.style.width = '100%';
            }
        }

        function expandCollapseAll(node, expand) {
            if (node._children && expand) {
                node.children = node._children;
                node._children = null;
            } else if (node.children && !expand) {
                node._children = node.children;
                node.children = null;
            }
            if (node.children) {
                node.children.forEach(child => expandCollapseAll(child, expand));
            }
        }

        function cloneDataWithoutTreeProps(data) {
            const copy = JSON.parse(JSON.stringify(data));
            // Strip any existing tree references so only our single path renders
            delete copy.children;
            delete copy._children;
            return copy;
        }

        function openChainDrawer(node) {
            // Build only root -> clicked chain
            const chain = node.ancestors().reverse();

            // Build a minimal linear hierarchy with NO side branches
            const rootData = cloneDataWithoutTreeProps(chain[0].data);
            let current = rootData;
            for (let i = 1; i < chain.length; i++) {
                const childCopy = cloneDataWithoutTreeProps(chain[i].data);
                current.children = [childCopy];  // single path only
                current = childCopy;
            }

            // Convert to d3.hierarchy
            const chainRoot = d3.hierarchy(rootData);

            // Layout as a tree
            const treeLayout = d3.tree().nodeSize([120, 100]);
            treeLayout(chainRoot);

            // Render into drawer
            renderChainTree(chainRoot);

        }

        function renderChainTree(root) {
            const svg = d3.select("#chain-container svg");
            svg.selectAll("*").remove();

            const nodes = root.descendants();
            const links = root.links();

            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            let width = xExtent[1] - xExtent[0] + 700;
            let height = yExtent[1] - yExtent[0] + 150;
            svg.attr("width", width).attr("height", height);

            const g = svg.append("g")
                .attr("transform", `translate(${80 - xExtent[0]},0)`);

            // Links
            g.selectAll(".link")
                .data(links)
                .join("path")
                .attr("stroke", "#999")
                .attr("fill", "none")
                .attr("stroke-width", 2)
                .attr("d", d => `M${d.source.x - 10},${d.source.y + 60} L${d.target.x - 10},${d.target.y + 70}`);

            // Nodes
            const node = g.selectAll(".node")
                .data(nodes)
                .join("g")
                .attr("transform", d => `translate(${d.x},${d.y + 30})`);

            node.append("rect")
                .attr("x", -50).attr("y", 20)
                .attr("width", 80).attr("height", 80)
                .attr("rx", "50%").attr("ry", "50%")
                .attr("fill", "#e3f2fd")
                .attr("stroke", "#1565C0");

            node.append("image")
                .attr("class", "node-photo node-field-photo")
                .attr("href", d => d.data.profileImage)
                .attr("x", -45)
                .attr("y", 25)
                .attr("width", 70)
                .attr("height", 70)
                .attr("clip-path", "circle(35px at 35px 35px)")
                .style("cursor", "pointer");

            node.append("text")
                .attr("dy", "3.2em")
                .attr("x", 40)
                .attr("y", d => {
                    if (d.depth === 0) {
                        // root node → take first word of firstName
                        return 10;
                    } else {
                        return -10;
                    }
                })
                .attr("text-anchor", "start")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("font-family", "Verdana, 'Times New Roman', serif")
                .text(d => {
                    if (d.depth === 0) {
                        // root node → take first word of firstName
                        return truncateTextToWidth(d.data.firstName.split('(')[0], 140);
                    } else {
                        return truncateTextToWidth((d.data.firstName || '') + (d.data.lastName ? (' ' + d.data.lastName) : ''), 140)
                    }
                });

            node.append("text")
                .attr("dy", "3.2em")
                .attr("x", 40)
                .attr("y", d => {
                    if (d.depth === 0) {
                        // root node → take first word of firstName
                        return 30;
                    } else {
                        return 10;
                    }
                })
                .attr("text-anchor", "start")
                .style("font-size", "14px")
                .style("font-family", "Verdana, 'Times New Roman', serif")
                .text(d => {
                    if (d.depth === 0) {
                        // root node → take first word of firstName
                        return d.data.firstName && d.data.firstName.split('(').length > 1 ? "(" + d.data.firstName.split('(')[1] : "";
                    } else {
                        // others → normal role
                        let role = d.data.role || "";
                        if (d.data.role?.toLowerCase() == "territory manager" && d.data.territoryGroupDivisionName != null && d.data.territoryGroupDivisionName != "") {
                            role = role + " - " + ' (' + (d.data.territoryGroupDivisionName || '') + ')';
                        }
                        return role;
                    }
                });

            node.append("text")
                .attr("dy", "3.2em")
                .attr("x", 40)
                .attr("y", 30)
                .attr("text-anchor", "start")
                .style("font-size", "14px")
                .style("font-family", "Verdana, 'Times New Roman', serif")
                .text(d => {
                    return d.data.email || "";
                });

            node.append("text")
                .attr("dy", "3.2em")
                .attr("x", 40)
                .attr("y", 50)
                .attr("text-anchor", "start")
                .style("font-size", "14px")
                .style("font-family", "Verdana, 'Times New Roman', serif")
                .text(d => {
                    return d.data.jobTitle || "";
                });

            const popup = document.getElementById('node-popup');
            if (popup) {
                popup.style.display = 'block';
                popup.style.zIndex = '9999';
                popup.style.pointerEvents = 'auto';
                void popup.offsetWidth;
                popup.style.right = '0';
                const treeContainer = document.getElementById('tree-container');
                if (treeContainer) {
                    setTimeout(() => { treeContainer.style.width = '70%'; }
                        , 400); // match transition                                
                }
            }

        }

        const apiUrl = "https://force-uat-api.azurewebsites.net/api/v1/territories/territories/chart-data";

        // Initial load of the page
        loadData('current');

        // Error handling and loading indicator
        window.addEventListener('load', () => {
            // Set default selection
            document.querySelector('.type-select').value = 'current';
            document.querySelector('.date-picker').style.display = 'none';
        });

        function buildHierarchy(data) {
            try {
                if (!Array.isArray(data) || data.length === 0) {
                    throw new Error('Invalid data structure');
                }

                const map = {};
                data.forEach(d => {
                    if (d && d.nodeId) {
                        map[d.nodeId] = { ...d, children: [] };
                    }
                });

                let root = null;
                data.forEach(d => {
                    if (d.parentNodeId === null) {
                        root = map[d.nodeId];
                    } else if (map[d.parentNodeId] && map[d.nodeId]) {
                        map[d.parentNodeId].children.push(map[d.nodeId]);
                    }
                });

                if (!root) {
                    throw new Error('No root node found in data');
                }

                return d3.hierarchy(root);
            } catch (error) {
                console.error('Error building hierarchy:', error);
                throw error;
            }
        }

        function focusOnNode(d) {
            const container = document.getElementById("tree-container");
            const svg = container.querySelector("svg");

            // Current transform offset (translate)
            const g = svg.querySelector("g");
            const transform = g.getAttribute("transform"); // e.g. "translate(50,50)"
            const match = /translate\(([^,]+),([^)]+)\)/.exec(transform);
            const offsetX = match ? parseFloat(match[1]) : 0;
            const offsetY = match ? parseFloat(match[2]) : 0;

            // Node position in SVG coordinates
            const nodeX = d.x + offsetX;
            const nodeY = d.y + offsetY;

            // Center inside container
            const cx = nodeX - container.clientWidth / 2;
            const cy = nodeY - container.clientHeight / 2;

            container.scrollTo({
                left: cx,
                top: cy,
                behavior: "smooth"
            });
        }


        function layoutTree(root) {
            // Use D3's tree layout with fixed vertical spacing, as before
            const horizontalSpacing = 210; // More space between siblings
            let verticalSpacing = 140;  // Standard space between parent/child (reverted)
            const checkboxes = document.querySelectorAll('#customMultiSelectDropdown input[type="checkbox"]');
            const selected = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            if (selected.includes('photo') && (selected.includes('email') || selected.includes('jobtitle'))) {
                // If all fields are selected, increase vertical spacing to accommodate larger boxes
                verticalSpacing = 160; // Uncomment if needed
            }
            if (selected != null && selected.length == 1) {
                verticalSpacing = 120; // More space for single field to avoid overlap
            }
            const treeLayout = d3.tree()
                .nodeSize([horizontalSpacing, verticalSpacing])
                .separation((a, b) => {
                    if (a.parent === b.parent) {
                        const siblings = a.parent.children || [];
                        const allLeaves = siblings.every(c => !(c.children || c._children));
                        if (allLeaves) return 0; // no horizontal separation
                    }
                    return 1; // default spacing
                });
            treeLayout(root);

            root.each(node => {
                if (node.children && node.children.length > 1) {
                    const allLeaves = node.children.every(c => !(c.children || c._children));
                    if (allLeaves) {
                        node.children.forEach((c, i) => {
                            c.x = node.x; // same horizontal position as parent
                            c.y = node.y + (i + 1) * 130; // vertical spacing
                        });
                    }
                }
            });
            // Removed manual leaf positioning to prevent overlap; let D3 handle spacing

            const allNodes = root.descendants();
            if (!window._centerRootNextRender) {
                const minX = d3.min(allNodes, d => d.x);
                allNodes.forEach(d => {
                    d.x = d.x - minX + 20;
                });
            }
            window._centerRootNextRender = false;
        }


        function renderTree(root) {
            const svg = d3.select("svg");
            svg.selectAll("*").remove();

            const nodes = root.descendants();
            const links = root.links();

            // Get selected fields from dropdown
            const checkboxes = document.querySelectorAll('#customMultiSelectDropdown input[type="checkbox"]');
            const selected = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);

            let OnlyOneFieldSelected = false;
            if (selected != null && selected.length == 1) {
                OnlyOneFieldSelected = true;
            }
            // Define boxWidth and nameRoleMaxWidth at the top so they are available everywhere
            const boxWidth = 100; // Smaller default width
            let nameRoleMaxWidth = boxWidth - 12;

            // Helper to measure text width
            function measureText(text, fontSize = 15, fontWeight = 'bold') {
                const tempSvg = d3.select('body').append('svg').attr('width', 0).attr('height', 0);
                const tempText = tempSvg.append('text')
                    .style('font-size', fontSize + 'px')
                    .style('font-weight', fontWeight)
                    .style('font-family', 'Segoe UI, Arial, sans-serif')
                    .text(text);
                const width = tempText.node().getComputedTextLength();
                tempSvg.remove();
                return width;
            }

            // Compute box size for each node based on visible fields
            const minBoxWidth = 100;
            const minBoxHeight = 100;
            const nodeBoxYOffset = 20;
            let IsAllFieldAvailable = false;
            let IsEmailOrJobTitleFieldAvailable = false;
            nodes.forEach(d => {
                const hasPhoto = selected.includes('photo');
                const textX = hasPhoto ? 56 + 24 : 20; // 56px photo + 24px padding, or just 20px padding
                const fieldOrder = [];
                if (selected.includes('name')) fieldOrder.push('name');
                if (selected.includes('role')) fieldOrder.push('role');
                if (selected.includes('email')) fieldOrder.push('email');
                if (selected.includes('jobtitle')) fieldOrder.push('jobtitle');

                // Calculate text block height and max width
                let textBlockHeight = 0;
                let maxTextWidth = 0;
                fieldOrder.forEach(field => {
                    let text = '';
                    let fontSize = 15;
                    let fontWeight = 'bold';
                    if (field === 'name') {
                        text = (d.data.firstName + ' ' + (d.data.lastName || '')).trim();
                        fontSize = 15;
                        fontWeight = 'bold';
                    } else if (field === 'role') {
                        text = (d.data.role || '').trim();
                        fontSize = 12;
                        fontWeight = '400';
                    } else if (field === 'email') {
                        text = d.data.email || '';
                        fontSize = 12;
                        fontWeight = '400';
                    } else if (field === 'jobtitle') {
                        text = d.data.jobTitle || '';
                        fontSize = 12;
                        fontWeight = '400';
                    }
                    const textW = measureText(text, fontSize, fontWeight);
                    maxTextWidth = Math.max(maxTextWidth, textW);
                    textBlockHeight += fontSize + 8; // 8px gap below each line
                });
                if (textBlockHeight > 0) textBlockHeight -= 8; // remove last gap

                // Calculate box size
                let boxWidth = 180;
                let boxHeight = 100;
                if (hasPhoto) {
                    if (selected.includes('email') && selected.includes('jobtitle')) {
                        boxHeight = 120;
                        IsAllFieldAvailable = true;
                    }
                    else if (selected.includes('email') || selected.includes('jobtitle')) {
                        boxHeight = 100;
                        IsEmailOrJobTitleFieldAvailable = true;
                    }
                }
                if (OnlyOneFieldSelected) {
                    boxHeight = 60;
                }
                d.boxWidth = boxWidth;
                d.boxHeight = boxHeight;
                d.textX = textX;
                d.textBlockHeight = textBlockHeight;
            });

            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);

            // Calculate bounding box for the tree
            const minWidth = 900;
            const minHeight = 600;
            let width = xExtent[1] - xExtent[0] + 300;
            let height = yExtent[1] - yExtent[0] + 300;
            if (width < minWidth) width = minWidth;
            if (height < minHeight) height = minHeight;
            svg.attr("width", width).attr("height", height);

            // Center the root node horizontally and vertically if requested (centerRoot flag)
            let centerRoot = false;
            if (arguments.length > 1 && arguments[1] === true) centerRoot = true;
            let translateX = 150 - xExtent[0];
            let translateY = 100 - yExtent[0];
            if (centerRoot && nodes.length > 0) {
                // Center the root node in the SVG viewport
                const rootNode = nodes[0];
                translateX = width / 2 - rootNode.x;
                translateY = height / 2 - rootNode.y;
            }

            const g = svg.append("g")
                .attr("transform", `translate(${translateX},${translateY})`);

            // Draw links between nodes
            g.selectAll(".link")
                .data(links)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => {
                    const role = d.target.data.role?.toLowerCase();
                    // Use linkColor from roleColors if available, else fallback to blue
                    return (roleColors[role]?.linkColor) || "#1565C0";
                })
                .attr("stroke-width", 2.5)
                .attr("fill", "none")
                .attr("d", d => {
                    const startX = d.source.x;
                    const startY = d.source.y + nodeBoxYOffset + (d.source.boxHeight || 110);
                    const endX = d.target.x;
                    const endY = d.target.y + nodeBoxYOffset;

                    const siblings = d.source.children || [];
                    const isLeaf = !(d.target.children || d.target._children);
                    if (siblings.length > 1 && isLeaf) {
                        // vertical line if multiple leaf children
                        return `M${startX},${startY} V${endY}`;
                    }

                    return `M${startX},${startY} V${(startY + endY) / 2} H${endX} V${endY}`;
                });

            // Draw nodes
            const node = g.selectAll(".node")
                .data(nodes)
                .join("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`); // d.y is now set by setY and includes extra spacing


            // Draw node box
            node.append("rect")
                .attr("class", "node-box")
                .attr("x", d => -d.boxWidth / 2)
                .attr("y", 20)
                .attr("width", d => d.boxWidth)
                .attr("height", d => d.boxHeight)
                .attr("rx", 18)
                .attr("ry", 18)
                .attr("fill", d => {
                    const role = d.data.role?.toLowerCase();
                    return roleColors[role]?.fill || "#f0f0f0";
                })
                .attr("stroke", d => {
                    const role = d.data.role?.toLowerCase();
                    return roleColors[role]?.stroke || "#1565C0";
                })
                .style("cursor", "pointer")
                .style("pointer-events", "all")
                .on("click", function (event, d) {
                    event.stopPropagation();
                    try {
                        showNodePopup(d);
                    } catch (e) {
                        console.error("Popup error:", e);
                    }
                });

            // Add profile image
            // Calculate Y positions for visible fields

            let isImageVisible = false;
            // Photo is always at the left, vertically centered with text block or box
            if (selected.includes('photo')) {
                isImageVisible = true;
                node.append("image")
                    .attr("class", "node-photo node-field-photo")
                    .attr("href", d => d.data.profileImage)
                    .attr("x", d => OnlyOneFieldSelected ? -30 : -d.boxWidth / 2 + 5)
                    .attr("y", (d) => {
                        if (d.depth == 0) {
                            return (d.boxHeight - 20) / 2;
                        }
                        return IsEmailOrJobTitleFieldAvailable ? 18 + (d.boxHeight - 80) / 2 : IsAllFieldAvailable ? 15 + (d.boxHeight - 90) / 2 : 20 + (d.boxHeight - 56) / 2
                    })
                    .attr("width", 56)
                    .attr("height", 56)
                    .attr("clip-path", "circle(28px at 28px 28px)")
                    .style("cursor", "pointer")
                    .on("click", function (event, d) {
                        event.stopPropagation();
                        try {
                            showNodePopup(d);
                        } catch (e) {
                            console.error("Popup error:", e);
                        }
                    });
            }
            else {
                nameRoleMaxWidth = boxWidth + 70;
            }

            // Always render all possible fields, toggle visibility for instant feedback
            node.each(function (d) {
                d3.select(this).selectAll('.node-label, .node-role, .node-email, .node-jobtitle').remove();
                const fieldDefs = [
                    {
                        key: 'name',
                        className: 'node-label node-field-name',
                        fontSize: 15,
                        fontWeight: 'bold',
                        fill: '#222',
                        getText: () => {
                            let name = (d.data.firstName + ' ' + (d.data.lastName || '')).trim();
                            if (d.depth === 0 && name.split('(').length > 1) {
                                name = name.split('(')[0].trim();
                            }
                            return truncateTextToWidth(name, isImageVisible ? nameRoleMaxWidth + 17 : nameRoleMaxWidth);
                        },
                        fullText: () => {
                            let name = (d.data.firstName + ' ' + (d.data.lastName || '')).trim();
                            if (d.depth === 0 && name.split('(').length > 1) {
                                name = name.split('(')[0].trim();
                            }
                            return name;
                        }
                    },
                    {
                        key: 'role',
                        className: 'node-role node-field-role',
                        fontSize: 12,
                        fontWeight: '400',
                        fill: '#555',
                        getText: () => {
                            let role = (d.data.role || '').trim();
                            if (d.depth === 0 && (d.data.firstName || '').split('(').length > 1) {
                                // root node → take only the part in parentheses from firstName
                                const firstName = d.data.firstName || '';
                                const parenPart = firstName.split('(').length > 1 ? "(" + firstName.split('(')[1] : '';
                                return truncateTextToWidth(parenPart, nameRoleMaxWidth + 50);
                            }
                            if (d.data.role?.toLowerCase() == "territory manager" && d.data.territoryGroupDivisionName != null && d.data.territoryGroupDivisionName != "") {
                                role = role + " - " + ' (' + (d.data.territoryGroupDivisionName || '') + ')';
                            }
                            return truncateTextToWidth(role, nameRoleMaxWidth + 50);
                        },
                        fullText: () => {
                            let role = (d.data.role || '').trim();
                            if (d.depth === 0 && (d.data.firstName || '').split('(').length > 1) {
                                // root node → take only the part in parentheses from firstName
                                const firstName = d.data.firstName || '';
                                const parenPart = firstName.split('(').length > 1 ? "(" + firstName.split('(')[1] : '';
                                return parenPart.trim();
                            }
                            if (d.data.role?.toLowerCase() == "territory manager" && d.data.territoryGroupDivisionName != null && d.data.territoryGroupDivisionName != "") {
                                role = role + " - " + ' (' + (d.data.territoryGroupDivisionName || '') + ')';
                            }
                            return role.trim();
                        }
                    },
                    {
                        key: 'email',
                        className: 'node-email node-field-email',
                        fontSize: 12,
                        fontWeight: '400',
                        fill: '#555',
                        getText: () => truncateTextToWidth(d.data.email || '',
                            IsAllFieldAvailable || IsEmailOrJobTitleFieldAvailable ? boxWidth + 65 : nameRoleMaxWidth, 12, '400'),
                        fullText: () => (d.data.email || '').trim()
                    },
                    {
                        key: 'jobtitle',
                        className: 'node-jobtitle node-field-jobtitle',
                        fontSize: 12,
                        fontWeight: '400',
                        fill: '#555',
                        getText: () => truncateTextToWidth(d.data.jobTitle || '', IsAllFieldAvailable || IsEmailOrJobTitleFieldAvailable ? boxWidth + 65 : nameRoleMaxWidth, 12, '400'),
                        fullText: () => (d.data.jobTitle || '').trim()
                    }
                ];
                // Only visible fields affect vertical stacking
                let y = 25 + (d.boxHeight - d.textBlockHeight) / 2;
                if (IsAllFieldAvailable) {
                    y = 30 + (d.boxHeight - d.textBlockHeight) / 2;
                }
                let IsNameOrJobAvailable = false;
                if (selected.includes('name') && selected.includes('role')) {
                    IsNameOrJobAvailable = false;
                }
                else if (selected.includes('name') || selected.includes('role')) {
                    IsNameOrJobAvailable = true;
                }
                else if ((IsAllFieldAvailable || IsEmailOrJobTitleFieldAvailable) && !(selected.includes('name') && selected.includes('role'))) {
                    y = 50 + (d.boxHeight - d.textBlockHeight) / 2;
                }
                fieldDefs.forEach(field => {
                    if (selected.includes(field.key)) {
                        d3.select(this).append('text')
                            .attr('class', field.className)
                            .attr('x', () => {
                                if (d.depth == 0 && !isImageVisible) {
                                    return -0; // center the root node text if no image
                                }
                                if (OnlyOneFieldSelected || (!isImageVisible && (field.key == 'name' || field.key == 'role'))) {
                                    return -0; // center
                                } else if (field.key === 'jobtitle' || field.key === 'email') {
                                    return -d.boxWidth / 2 + 5;
                                } else if (!isImageVisible) {
                                    return -d.boxWidth / 2 + 5;
                                } else {
                                    return -d.boxWidth / 2 + d.textX - 10;
                                }
                            })
                            .attr('y', () => {
                                if (d.depth == 0 && (field.key != 'role' && field.key != 'name')) {
                                    return 0;
                                }
                                if (d.depth == 0 && (field.key == 'name')) {
                                    return y = 10 + (d.boxHeight / 2);
                                }
                                if (d.depth == 0 && (field.key == 'role')) {
                                    return y = y + 20;
                                }
                                return (field.key == 'jobtitle' || field.key == 'email') && (IsAllFieldAvailable || IsEmailOrJobTitleFieldAvailable) && IsNameOrJobAvailable
                                    ? y + 10 : y;
                            })
                            .attr('dy', '0.4em')
                            .attr('text-anchor', () => {
                                if (d.depth == 0 && !isImageVisible) {
                                    return 'middle'; // center the root node text if no image
                                }
                                return (OnlyOneFieldSelected || (!isImageVisible && (field.key == 'name' || field.key == 'role'))) ? 'middle' : 'start';
                            })
                            .style('font-size', field.fontSize + 'px')
                            .style('font-weight', field.fontWeight)
                            .style('fill', field.fill)
                            .style('cursor', 'pointer')
                            .text(field.getText)
                            .on('click', function (event) {
                                event.stopPropagation();
                                try {
                                    showNodePopup(d);
                                } catch (e) {
                                    console.error("Popup error:", e);
                                }
                            })
                            .append('title')
                            .text(field.fullText);

                        if (d.depth == 0) {
                            y = y;
                        }
                        else {
                            y += field.fontSize + 8;
                        }
                    }
                });
            });

            const nameRoleX = -84;
            const jobEmailX = -100;
            // (Removed duplicate declaration of boxWidth and nameRoleMaxWidth)
            const jobEmailMaxWidth = boxWidth - 10;

            // Name
            // ...removed duplicate static text rendering for name...

            // Role
            // ...removed duplicate static text rendering for role...

            // Job Title
            // ...removed duplicate static text rendering for jobtitle...

            // Email
            // ...removed duplicate static text rendering for email...

            // Add toggle expand/collapse icons
            const toggleNodes = node.filter(d => d.children || d._children);
            const svgForGrad = d3.select('svg');
            if (svgForGrad.select('defs#toggle-gradient-defs').empty()) {
                const defs = svgForGrad.append('defs').attr('id', 'toggle-gradient-defs');
                const grad = defs.append('linearGradient')
                    .attr('id', 'toggle-blue-gradient')
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '0%').attr('y2', '100%');
                grad.append('stop').attr('offset', '0%').attr('stop-color', '#1565C0');
                grad.append('stop').attr('offset', '100%').attr('stop-color', '#42a5f5');
            }

            // Use per-node boxHeight for dynamic sizing
            const iconY = d => nodeBoxYOffset + (d.boxHeight || 110);

            toggleNodes.append("circle")
                .attr("class", "toggle-circle")
                .attr("cx", 0)
                .attr("cy", d => iconY(d))
                .attr("r", 11)
                .attr("fill", "url(#toggle-blue-gradient)")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .style("filter", "drop-shadow(0 1px 2px rgba(25,118,210,0.10))")
                .style("cursor", "pointer")
                .on("click", function (event, d) {
                    event.stopPropagation();
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else if (d._children) {
                        d.children = d._children;
                        d._children = null;
                        d.children.forEach(child => {
                            if (child.children) {
                                child._children = child.children;
                                child.children = null;
                            }
                        });
                    }
                    saveNodeState(currentType, root); // Save after toggle
                    layoutTree(root);
                    renderTree(root);
                    focusOnNode(d);
                    updateNodeFieldsVisibility();
                });


            // Horizontal line
            toggleNodes.append("path")
                .attr("d", d => `M${-6.5},${iconY(d)} H${6.5}`)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2.2)
                .attr("stroke-linecap", "round")
                .style("cursor", "pointer")
                .on("click", function (event, d) {
                    event.stopPropagation();
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else if (d._children) {
                        d.children = d._children;
                        d._children = null;
                        d.children.forEach(child => {
                            if (child.children) {
                                child._children = child.children;
                                child.children = null;
                            }
                        });
                    }
                    layoutTree(root);
                    renderTree(root);
                    updateNodeFieldsVisibility();
                });
            // Vertical line for collapsed nodes only
            toggleNodes.filter(d => !d.children)
                .append("path")
                .attr("d", d => `M0,${iconY(d) - 7} V${iconY(d) + 7}`)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2.2)
                .attr("stroke-linecap", "round")
                .style("cursor", "pointer")
                .on("click", function (event, d) {
                    event.stopPropagation();
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else if (d._children) {
                        d.children = d._children;
                        d._children = null;
                        d.children.forEach(child => {
                            if (child.children) {
                                child._children = child.children;
                                child.children = null;
                            }
                        });
                    }
                    layoutTree(root);
                    renderTree(root);
                    updateNodeFieldsVisibility();
                });


            // Always re-attach close button event to ensure it works after re-render
            const closeBtn = document.getElementById('close-popup-btn');
            if (closeBtn) {
                closeBtn.onclick = function () {
                    const popup = document.getElementById('node-popup');
                    if (popup) {
                        popup.style.right = '-550px';
                        setTimeout(() => { popup.style.display = 'none'; }, 400); // match transition
                    }
                    const treeContainer = document.getElementById('tree-container');
                    if (treeContainer) {
                        treeContainer.style.width = '100%';
                    }
                };
            }

            window.showNodePopup = function (node) {

                const data = node.data;  // keep JSON for details
                const popup = document.getElementById('node-popup');
                const content = document.getElementById('popup-content');
                if (!popup || !content) return;
                // Fill in details
                content.innerHTML = `
                <div style="display: flex; align-items: start; margin-bottom: 24px; width: 100%; flex-direction: column;">

    <!-- Header Section -->
    <div style="background-color: #1976D2; color: white; height: 180px; width: 100%; position: relative;">

      <!-- Name centered at top -->
      <h2 style="margin: 0; font-size: 30px; text-align: center;margin-top:20px;">${data.firstName + ' ' + (data.lastName || '')}</h2>

      <!-- Profile Image at bottom center -->
    <img src="${data.profileImage}" alt="Profile"
         style="width: 160px; height: 160px; border-radius: 50%; border: 4px solid white;
            position: absolute; left: 50%; transform: translateX(-50%);
            bottom: -80px;">
    </div>  

    
    <div style="background-color: #fff; color: white; padding-top: 20px; padding-bottom: 10px; text-align: center;display: flex;">
        <!-- Details Section 
      <div style="margin-top: 10px; text-align: left; padding: 0 20px;">
        <p style="margin: 5px 0; color: #000;">Name</p>
        <p style="margin: 5px 0px 15px 0px; color: #000;">${data.firstName + ' ' + (data.lastName || '')}</p>

        <p style="margin: 5px 0; color: #000;">Email</p>
        <p style="margin: 5px 0px 15px 0px; color: #000;">${data.email}</p>

        <p style="margin: 5px 0; color: #000;">Role</p>
        <p style="margin: 5px 0px 15px 0px; color: #000;">${data.role || ''}</p>

        <p style="margin: 5px 0; color: #000;">Job Title</p>
        <p style="margin: 5px 0px 15px 0px; color: #000;">${data.jobTitle || ''}</p>
      </div>-->
       <div id="chain-container">
      <svg></svg>
    </div>
    </div> 


  </div>            
            `;

                this.openChainDrawer(node);
            };

        }

        // Helper function to truncate text to fit max width in SVG
        function truncateTextToWidth(text, maxWidth, fontSize = 15, fontWeight = 'bold', fontFamily = 'Segoe UI, Arial, sans-serif') {
            // Create a temporary SVG text element to measure width
            const tempSvg = d3.select('body').append('svg').attr('width', 0).attr('height', 0);
            const tempText = tempSvg.append('text')
                .style('font-size', fontSize + 'px')
                .style('font-weight', fontWeight)
                .style('font-family', fontFamily)
                .text(text);
            let displayText = text;
            let truncated = false;
            while (tempText.node().getComputedTextLength() > maxWidth && displayText.length > 0) {
                displayText = displayText.slice(0, -1);
                truncated = true;
                tempText.text(displayText + '...');
            }
            let result = tempText.text();
            // Only show ellipsis if text was actually truncated
            if (!truncated) {
                result = text;
            }
            tempSvg.remove();
            return result;
        }

        // Store last selected fields to avoid unnecessary re-renders
        let lastSelectedFields = [];
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        // Add spinner element to DOM (hidden by default)
        if (!document.getElementById('tree-loading-spinner')) {
            const spinner = document.createElement('div');
            spinner.id = 'tree-loading-spinner';
            spinner.style.position = 'fixed';
            spinner.style.top = '0';
            spinner.style.left = '0';
            spinner.style.width = '100vw';
            spinner.style.height = '100vh';
            spinner.style.background = 'rgba(255,255,255,0.5)';
            spinner.style.display = 'flex';
            spinner.style.alignItems = 'center';
            spinner.style.justifyContent = 'center';
            spinner.style.zIndex = '99999';
            spinner.style.display = 'none';
            spinner.innerHTML = '<div style="border: 6px solid #e3f0ff; border-top: 6px solid #1976D2; border-radius: 50%; width: 48px; height: 48px; animation: spin 1s linear infinite;"></div>';
            document.body.appendChild(spinner);
            // Add keyframes for spin
            const style = document.createElement('style');
            style.innerHTML = '@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }';
            document.head.appendChild(style);
        }

        function showSpinner() {
            document.getElementById('tree-loading-spinner').style.display = 'flex';
        }
        function hideSpinner() {
            document.getElementById('tree-loading-spinner').style.display = 'none';
        }

        function updateNodeFieldsVisibility() {
            // Use cached selected fields if available, else fallback to DOM
            let selected = typeof getSelectedFields === 'function' ? getSelectedFields() : Array.from(document.querySelectorAll('#customMultiSelectDropdown input[type="checkbox"]')).filter(cb => cb.checked).map(cb => cb.value).sort();
            // Only update if fields actually changed
            if (!arraysEqual(selected, lastSelectedFields)) {
                // Determine if box size/layout fields changed (photo or name)
                const affectsLayout = (arr1, arr2) => {
                    const layoutFields = ['photo', 'name'];
                    return layoutFields.some(f => arr1.includes(f) !== arr2.includes(f));
                };
                const layoutChanged = true;
                lastSelectedFields = selected.slice();
                if (layoutChanged) {
                    showSpinner();
                    setTimeout(() => {
                        if (typeof treeRoot !== 'undefined' && treeRoot) {
                            layoutTree(treeRoot);
                            renderTree(treeRoot);
                        }
                        hideSpinner();
                    }, 50);
                } else {
                    // Only show/hide fields in-place for instant feedback
                    document.querySelectorAll('.node-field-jobtitle').forEach(el => el.style.display = selected.includes('jobtitle') ? '' : 'none');
                    document.querySelectorAll('.node-field-photo').forEach(el => el.style.display = selected.includes('photo') ? '' : 'none');
                    document.querySelectorAll('.node-field-name').forEach(el => el.style.display = selected.includes('name') ? '' : 'none');
                    document.querySelectorAll('.node-field-role').forEach(el => el.style.display = selected.includes('role') ? '' : 'none');
                    document.querySelectorAll('.node-field-email').forEach(el => el.style.display = selected.includes('email') ? '' : 'none');
                }
            }
        }

        function enableMouseDragScroll(container) {
            let isDown = false;
            let startX, startY;
            let scrollLeft, scrollTop;

            container.addEventListener('mousedown', (e) => {
                isDown = true;
                container.classList.add('dragging');
                startX = e.pageX - container.offsetLeft;
                startY = e.pageY - container.offsetTop;
                scrollLeft = container.scrollLeft;
                scrollTop = container.scrollTop;
            });

            container.addEventListener('mouseleave', () => {
                isDown = false;
                container.classList.remove('dragging');
            });

            container.addEventListener('mouseup', () => {
                isDown = false;
                container.classList.remove('dragging');
            });

            container.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - container.offsetLeft;
                const y = e.pageY - container.offsetTop;
                const walkX = x - startX;
                const walkY = y - startY;
                container.scrollLeft = scrollLeft - walkX;
                container.scrollTop = scrollTop - walkY;
            });
        }

        // Enable drag scrolling on page load
        document.addEventListener("DOMContentLoaded", function () {
            const container = document.getElementById('tree-container');
            enableMouseDragScroll(container);
        });
    </script>
</body>

</html>

